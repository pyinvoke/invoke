=======================
Constructing namespaces
=======================

The base case of loading a single module of tasks works fine initially, but
advanced users typically need more organization, such as separating tasks into
a tree of nested namespaces.

The `~invoke.collection.Collection` class provides an API for organizing tasks
and sub-collections. Collections may include tasks as well as other
collections, and form trees of tasks. When referenced by strings (e.g. on the
CLI or in pre/post hooks) tasks are referenced in a dot syntax, such as
`docs.build`.

In this section, we show how building namespaces with this API is flexible but
also allows following Python package layouts with minimal boilerplate.

Starting out
============

One unnamed ``Collection`` is always the namespace root; in the implicit base
case, Invoke creates one for you from the tasks in your tasks module.  Create
your own, named ``namespace`` or ``ns``, to set up an explicit namespace::

    from invoke import Collection

    ns = Collection()

Add tasks with `~invoke.collection.Collection.add_task`. ``add_task`` can take
an `~invoke.tasks.Task` object, such as those generated by the
`~invoke.tasks.task` decorator, or can be given a callable object directly.

::
    from invoke import task, run

    @task
    def release():
        run("python setup.py sdist register upload")

    ns.add_task(release)

Our available tasks list now looks like this::

    $ invoke --list
    Available tasks:

        release

Naming your tasks
=================

By default, a task's function name is used as its namespace identifier, but you
may override this with the ``name`` argument::

    ns = Collection()
    ns.add_task(release, name='deploy')

.. note::
    The ``name`` kwarg is the 2nd overall argument, so those in a hurry can
    simply say::

        ns.add_task(release, 'deploy')

The result::

    $ invoke --list
    Available tasks:

        deploy

Tasks may have additional names or aliases, given as the ``aliases`` keyword
argument; these are appended to, instead of replacing, any implicit or explicit
``name`` value::

    ns.add_task(release, aliases=('deploy', 'pypi'))

Result, with three names for the same task::

    $ invoke --list
    Available tasks:

        release
        deploy
        pypi

.. note::
    The convenience decorator `@task <~invoke.tasks.task>` is another method of
    setting aliases (e.g. ``@task(aliases=('foo', 'bar'))``, and is useful for
    ensuring a given task always has some aliases set no matter how it's added
    to a namespace.
        
Nesting collections
===================

The point of namespacing is to have sub-namespaces; to do this in Invoke,
create additional ``Collection`` instances and add them to their parent
collection via `~invoke.collection.Collection.add_collection`. For example,
let's say we have a couple of documentation tasks::

    @task
    def build_docs():
        run("sphinx-build docs docs/_build")

    @task
    def clean_docs():
        run("rm -rf docs/_build")

We can bundle them up into a new, named collection like so::

    docs = Collection('docs')
    docs.add_task(build_docs, 'build')
    docs.add_task(clean_docs, 'clean')

And then add this new collection under the root namespace with
``add_collection``::

    ns.add_collection(docs)

The result (assuming for now that ``ns`` currently just contains the original
``release`` task)::

    $ invoke --list
    Available tasks:

        release
        docs.build
        docs.clean

As with tasks, collections may be explicitly bound to their parents with a
different name than they were originally given (if any) via a ``name`` kwarg
(also, as with ``add_task``, the 2nd regular arg)::

    ns.add_collection(docs, 'sphinx')

Result::

    $ invoke --list
    Available tasks:

        release
        sphinx.build
        sphinx.clean

Importing modules as collections
================================

A simple tactic which Invoke itself uses in the trivial, single-module
case is to use `~invoke.collection.Collection.from_module` -- a classmethod
serving as an alternate ``Collection`` constructor which takes a Python module
object as its first argument.

Modules given to this method are scanned for any ``Task`` instances, which are
then added to the new collection automatically.  The collection's name is
simply taken from the module name (the ``__name__`` attribute).

For example, let's reorganize our earlier single-file example into a Python
package with several submodules. First, ``tasks/release.py``::

    from invoke import task, run

    @task
    def release():
        run("python setup.py sdist register upload")

And ``tasks/docs.py``::

    from invoke import task, run

    @task
    def build():
        run("sphinx-build docs docs/_build")

    @task
    def clean():
        run("rm -rf docs/_build")

Tying them together is ``tasks/__init__.py``::

    from invoke import Collection

    import release, docs

    ns = Collection()
    ns.add_collection(Collection.from_module(release))
    ns.add_collection(Collection.from_module(docs))

A little unwieldy in practice. Thankfully there's a shortcut here, which is
that ``add_collection`` will notice when handed a module object as its first
argument and call ``Collection.from_module`` for you internally::

    ns = Collection()
    ns.add_collection(release)
    ns.add_collection(docs)

Either way, the result::

    $ invoke --list
    Available tasks:

        release.release
        docs.build
        docs.clean

Mix and match
=============

You're not limited to the specific tactics shown above -- now that you know
the basic tools of ``add_task`` and ``add_collection``, use whatever approach
best fits your needs.

For example, let's say you wanted to keep things organized into submodules, but
wanted to "promote" ``release.release`` back to the top level for convenience's
sake. Just because it's in a module doesn't mean we must use ``add_collection``
-- simply import the task itself and use ``add_task`` directly::

    from invoke import Collection

    import docs
    from release import release

    ns = Collection()
    ns.add_collection(docs)
    ns.add_task(release)

Result::

    $ invoke --list
    Available tasks:

        release
        docs.build
        docs.clean

More shortcuts
==============

Finally, you can even skip ``add_collection`` and ``add_task`` if your needs
are simple enough -- `~invoke.collection.Collection`'s constructor will take
unknown arguments and build the namespace from their values as
appropriate::

    from invoke import Collection

    import docs, release

    ns = Collection(release.release, docs)

Notice how we gave both a task object (``release.release``) and a module
containing tasks (``docs``). The result is identical to the above::

    $ invoke --list
    Available tasks:

        release
        docs.build
        docs.clean

If given as keyword arguments, the keywords act like the ``name`` arguments do
in the ``add_*`` methods. Naturally, both can be mixed together as well::

    ns = Collection(docs, deploy=release.release)

Result::

    $ invoke --list
    Available tasks:

        deploy
        docs.build
        docs.clean

.. note::
    You can still name these ``Collection`` objects with a leading string
    argument if desired, which can be handy when building sub-collections.
